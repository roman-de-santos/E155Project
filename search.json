[
  {
    "objectID": "team.html",
    "href": "team.html",
    "title": "Team",
    "section": "",
    "text": "Cameron Hernandez\nMy name is Cameron Hernandez, I am a Senior at Harvey Mudd College currently perusing a bachelors in engineering. I am is passionate about electronic hardware and circuit designs. I have expierence ranging from working with power electronincs, desigining autonomous robotics, simulating electrically small antennas, and creating a multicycle processor. Stepping away from electrical engineering, I have taken engineering courses in the chemical, mechanical, material, and systems domains.\nConnect on LinkedIn\n\n\n\nLucas Lemos\nLucas Lemos is a senior undergraduate at Harvey Mudd College studying for a B.S. Engineering. He is a self-motivated engineer & student leader passionate about merging creative design and technical expertise. He has proficiency and interest in controls and electronics. Lucas has designed an embedded audio system and PCB for Motiv Electric Trucks, an analog instrumentation PCB for the HRL Labs Clinic Team, a QTP test rack for qualifying the reactor control system PCBAs for Radiant Nuclear, and is currently developing power electronics for the Exolambda Clinic team.\nConnect on LinkedIn\n\n\n\nHello, I’m Roman a student who is passionate about low-level systems. This includes C, Assembly, and IC/circuit design. I have been a TA for Computer Science, Physics, and Intro IC Lab. I am comfortable with many common Engineering software programs (Solidworks, ComSol, and Fusion) and computer languages (Matlab, Python, Java, Java Script, HTML, and C). So far, my favorite project I’ve worked on is my 32-bit CPU verification project.\nRoman De Santos\nConnect on LinkedIn"
  },
  {
    "objectID": "team.html#meet-the-team",
    "href": "team.html#meet-the-team",
    "title": "Team",
    "section": "",
    "text": "Cameron Hernandez\nMy name is Cameron Hernandez, I am a Senior at Harvey Mudd College currently perusing a bachelors in engineering. I am is passionate about electronic hardware and circuit designs. I have expierence ranging from working with power electronincs, desigining autonomous robotics, simulating electrically small antennas, and creating a multicycle processor. Stepping away from electrical engineering, I have taken engineering courses in the chemical, mechanical, material, and systems domains.\nConnect on LinkedIn\n\n\n\nLucas Lemos\nLucas Lemos is a senior undergraduate at Harvey Mudd College studying for a B.S. Engineering. He is a self-motivated engineer & student leader passionate about merging creative design and technical expertise. He has proficiency and interest in controls and electronics. Lucas has designed an embedded audio system and PCB for Motiv Electric Trucks, an analog instrumentation PCB for the HRL Labs Clinic Team, a QTP test rack for qualifying the reactor control system PCBAs for Radiant Nuclear, and is currently developing power electronics for the Exolambda Clinic team.\nConnect on LinkedIn\n\n\n\nHello, I’m Roman a student who is passionate about low-level systems. This includes C, Assembly, and IC/circuit design. I have been a TA for Computer Science, Physics, and Intro IC Lab. I am comfortable with many common Engineering software programs (Solidworks, ComSol, and Fusion) and computer languages (Matlab, Python, Java, Java Script, HTML, and C). So far, my favorite project I’ve worked on is my 32-bit CPU verification project.\nRoman De Santos\nConnect on LinkedIn"
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "MicroP’s Website: E155\nCommunication Protocol outline: I2S NXP Spec\nDAC control signals: StackExchange"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 Project Portfolio",
    "section": "",
    "text": "This project implements a digital guitar pedal capable of applying a real-time chorus effect to an instrument input. The system utilizes a hybrid architecture featuring a microcontroller (MCU), an FPGA, an external DAC, and custom analog circuitry. The analog front-end passes the guitar input through gain scaling and offset adjustment, followed by 4th-order anti-aliasing filters. The signal is then digitized by the MCU’s internal ADC and transferred via DMA to an SAI module for output in I2S format.\nThe FPGA decodes the incoming I2S data and routes it to a DSP module, which utilizes SRAM to generate the chorus modulation. Finally, the processed audio is packaged and transmitted out to an external DAC via I2S, converted back to an analog signal, and scaled to a safe output range suitable for a standard guitar amplifier."
  },
  {
    "objectID": "index.html#abstract",
    "href": "index.html#abstract",
    "title": "E155 Project Portfolio",
    "section": "",
    "text": "This project implements a digital guitar pedal capable of applying a real-time chorus effect to an instrument input. The system utilizes a hybrid architecture featuring a microcontroller (MCU), an FPGA, an external DAC, and custom analog circuitry. The analog front-end passes the guitar input through gain scaling and offset adjustment, followed by 4th-order anti-aliasing filters. The signal is then digitized by the MCU’s internal ADC and transferred via DMA to an SAI module for output in I2S format.\nThe FPGA decodes the incoming I2S data and routes it to a DSP module, which utilizes SRAM to generate the chorus modulation. Finally, the processed audio is packaged and transmitted out to an external DAC via I2S, converted back to an analog signal, and scaled to a safe output range suitable for a standard guitar amplifier."
  },
  {
    "objectID": "index.html#video-demonstration",
    "href": "index.html#video-demonstration",
    "title": "E155 Project Portfolio",
    "section": "Video Demonstration",
    "text": "Video Demonstration"
  },
  {
    "objectID": "index.html#block-diagram",
    "href": "index.html#block-diagram",
    "title": "E155 Project Portfolio",
    "section": "Block Diagram",
    "text": "Block Diagram\n\n\n\nFigure 1: Top Block Diagram"
  },
  {
    "objectID": "index.html#acknowledgements",
    "href": "index.html#acknowledgements",
    "title": "E155 Project Portfolio",
    "section": "Acknowledgements",
    "text": "Acknowledgements\nAs a team we want to thank Prof. Spencer for providing valuable feedback on all our submitted assignments to help us form better code writing habits. We also want to thank Xavier for helping us with debugging on the circuit."
  },
  {
    "objectID": "documentation.html",
    "href": "documentation.html",
    "title": "Documentation",
    "section": "",
    "text": "New Communication Protocol Section 1\nNew Hardware Section 2\n\nPCM5102 DAC Section 2.1\nOp Amp Hardware Section 2.2\n\nSchematics Section 3\nAnalog Block Diagram Section 4\nBill of Materials Section 5\nGithub Breakdown Section 6"
  },
  {
    "objectID": "documentation.html#sec-new-protocol",
    "href": "documentation.html#sec-new-protocol",
    "title": "Documentation",
    "section": "1 New Protocol I2S",
    "text": "1 New Protocol I2S\nThis section discusses the protocol used to communicate between the FPGA, MCU, and the DAC. Our group decided to use the I2S Standard format ( NXP Semiconductors) due to it being a standard audio format that at an initial review seemed relativly easy to implement in verilog.\nFrom the image below, the I2S shows how the input data (SD) is serialized and uses a reference clock (sclk) to transfer the bits. word select (ws) dictates wether the line is transfering left or right chanel audio, where ws=0 means left chanel and ws=1 means right chanel. Since our group decided to do mono audio our data packet was duplicated accross both the left and right channel.\n\n\n\nFigure 1: I2S 3 Wire Protocol by NXP Semiconductors\n\n\nNotice that the MSB of the current frame is one cycle delayed after WS toggles. For us it was also important to realize data by a transmitter is set on the negative edge of sclk while a reciever reads data on the positive edge of sclk. This prevents metastability issues making the protocol more reliable.\nThe overall bitsize is configurable, but we decided to use 16 bit audio since that was the minimum our DAC supported and our ADC only had a resolution of 12 bits."
  },
  {
    "objectID": "documentation.html#sec-new-hardware",
    "href": "documentation.html#sec-new-hardware",
    "title": "Documentation",
    "section": "2 New Hardware",
    "text": "2 New Hardware\nThis section contains a listing of our new hardware and a short description of its implementation.\n\n2.1 PCM5102 DAC\nThis DAC was the most critical new component we using in our project. This DAC has native support for I2S to analog output. This circuit is also able to generate its own master clock based on the WS input\nThis bord uses a slightly different naming convention for the inputs compared to the official NXP Semiconductors standard, but the convention is similar.\n\nNaming Convention Clarification\n\n\n\n\n\n\n\n\nPCM5102 Naming\nNXP Standard\nRequired?\nFunction\n\n\n\n\nSCLK\nMCLK\nNo\nMaster CLock for filtering/reference\n\n\nBCK\nSCLK\nYes\nBit clock\n\n\nDIN\nSD\nYes\nSerial data\n\n\nLCK\nWS\nYes\nLeft/Right select\n\n\n\nThis DAC has control pins that can be shorted to H/L pads to reduce wiring complexity. Figure 2 shows these pins on the back of the DAC, labled HxL (x ranges from 1-4).\n\n\n\nFigure 2: DAC Control Pins\n\n\nThe functionality of these pins are as follows (from this forum):\n\nFLT - Filter select : Normal latency (Low) / Low latency (High)\nDEMP - De-emphasis control for 44.1kHz sampling rate: Off (Low) / On (High)\nXSMT - Soft mute control(1): Soft mute (Low) / soft un-mute (High)\nFMT - Audio format selection : I2S (Low) / Left justified (High)\n\nNote we also grounded SCLK to ensure the master clock was internally generated by the chip.\nOur setup for I2S audio used:\n\nFLT : Low\nDEMP : Low\nXSMT : High\nFMT : Low\n\nAfter succesful setup, the dac was able to read I2S signals and correctly display its analog equivalent. This was tested by feeding a wavegen sinewave into the MCU’s ADC and passing the I2S output to the DAC and comparing the input and output waveform.\nThis peice of hardware introduced us to mixed signal processing, specifically in audio. Previously we had a lab, lab 4 where we used PWM waves to control a speaker. In this lab the output was strictly digital. With our new set up, our hardware expands on this and allows us to use many more intensity levels to create richer audio.\n\n\n2.2 Op-Amp Hardware\nFor this project MCP6002 op Amps were used for the analog conditioning. From Figure 3, the schematic shows the initial conditioning was done by op-Amps U1A and U1B. This stage centers the signal around 1.65V since the MCU’s ADC can only read voltages between 0-3.3V. The input guitar signal is also quite weak at a max of 300mV, so a gain of 10.1 is applied to the input signal to increase the dynamic range the MCU can read.\nThe next stage consists of op Amps U2A and U2B. These op amps are two 2nd-order sallen-key low-pass filters in series. The cuttoff frequency of this circuit is about 27.4KHz thus the -3dB point is pushed slightly higher to ensure the 20kHz audio band remains flat, but not too far. This helps reduce the presence of high frequency signals from the guitar when the ADC samples the signal.\nThe next analog section with active filtering by op Amps is connected to the DAC output. Here an op Amp is used to regulate the signal back to to a safe range for the guitar amp since the amp expects voltages in the range of 100s of mV. The ouput of this topology is passed through an AC couple to remove DC bias, centering the wave back at zero and removing the offset we added initially to place it in the range of 0-3.3V for the MCU. This allows us to use the bipolar output of the guitar amp."
  },
  {
    "objectID": "documentation.html#sec-schematics",
    "href": "documentation.html#sec-schematics",
    "title": "Documentation",
    "section": "3 Schematic",
    "text": "3 Schematic\nBelow in Figure 3 a schematic of our system is provided.The general flow of the diagram is left to right, top to bottom.\n\n\n\nFigure 3: Schematic"
  },
  {
    "objectID": "documentation.html#sec-block-diagram",
    "href": "documentation.html#sec-block-diagram",
    "title": "Documentation",
    "section": "4 Analog Block Diagram",
    "text": "4 Analog Block Diagram\nBelow in Figure 4 the Block diagram for the Analog input shown. For more detailed block diagrams of each section (MCU/FPGA) please check their respective page.\n\n\n\nFigure 4: Analog Block Diagram"
  },
  {
    "objectID": "documentation.html#sec-bill-of-materials",
    "href": "documentation.html#sec-bill-of-materials",
    "title": "Documentation",
    "section": "5 Bill of Materials",
    "text": "5 Bill of Materials\n\n\n\nItem Description\nPart Number\nSource\nQTY\nUnit Price\nShipping\nTax\nNet Cost\n\n\n\n\nDC Power Jack\nA-1656\nTayda Electronics\n1\n0.14\n1.19\n0.00\n1.33\n\n\nPedal Switch\nA7459\nTayda Electronics\n1\n2.70\n1.19\n0.00\n3.89\n\n\nPot Knobs Plastic\nA-4560\nTayda Electronics\n3\n0.42\n1.19\n0.00\n2.45\n\n\nPot Knobs Aluminium\nA-5966\nTayda Electronics\n3\n0.63\n1.19\n0.00\n3.08\n\n\nLinear Pot 10K\nA-8047\nTayda Electronics\n3\n0.59\n1.19\n0.00\n2.96\n\n\nLog Pot 10K\nA-1957\nTayda Electronics\n3\n0.50\n1.19\n0.00\n2.69\n\n\nPot Cover\nA-5527\nTayda Electronics\n3\n0.04\n1.19\n0.00\n1.31\n\n\nPCB Standoffs\nA-2868\nTayda Electronics\n7\n0.10\n1.19\n0.00\n1.89\n\n\n6.35mm Nut\nA-6441\nTayda Electronics\n3\n0.07\n1.19\n0.00\n1.40\n\n\n9V Battery Holder\nA-843\nTayda Electronics\n2\n0.47\n1.19\n0.00\n2.13\n\n\n6.35mm 1/4” Stereo socket\nA-5069\nTayda Electronics\n3\n0.38\n1.19\n0.00\n2.33\n\n\nEnclosure\nA-5837\nTayda Electronics\n1\n5.99\n1.19\n0.00\n7.18\n\n\n6.35mm 1/4” Mono Socket\nA-4556\nTayda Electronics\n2\n0.87\n1.19\n0.00\n2.93\n\n\n3PDT Nut\nA-4802\nTayda Electronics\n1\n0.39\n1.19\n0.00\n1.58\n\n\nDAC PCM5102\nB0DNW32Y46\nAmazon\n2\n4.44\n0\n0.44\n9.75\n\n\nTOTAL\n\n\n\n\n\n\n46.9"
  },
  {
    "objectID": "documentation.html#sec-github",
    "href": "documentation.html#sec-github",
    "title": "Documentation",
    "section": "6 Github",
    "text": "6 Github\nAll of our source code is found on our project’s github here. Notible files are listed below.\n\nFPGA/:\n\nDSP/ Contains the chorus effect DSP algorithm with testbenches\nI2S/ Contains I2S tx and rx module along with all testbench files\nLFO/ Folder with the code to generate low frequency oscilations with a look up table\nTOP/ A folder with all of the top module files and testbenches for the top module.\n\nLTspice/:\n\nAnalog simulation files to verify circuit\n\nMCU/STMcubeMX/:\n\ncore/ contains the src files and header files for the HAL library\nSTMcubeMX.ioc configuration file for HAL library\n\nQuarto/:\n\nAll of the website files for the project\n\nkiCAD/tremolo_guitar_pedal:\n\nAll of the kiCAD files for this project, including source and rendered schematics"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "FPGA.html",
    "href": "FPGA.html",
    "title": "FPGA",
    "section": "",
    "text": "This module is responsible for recieving the I2S data from the MCU and converting it into a 16 bit package for the Left and Right channel. This module is mainly a large shifter that shifts the data in and latches the channel values as described by the I2S module, describe in more detail under the documentation tab. This module uses the sclk input as a clock signal to drive the seqquential logic. It wasn’t until later that the team realized this might not have been standard practice and could lead to digital noise.\n\n\n\nThis module accepts the incoming packet from the I2S rx module and syncronizes it to the faster FPGA clock. This module computes the modified packet (wet packet) and mixes it back with the original input (dry packet) to create the mixed packet. Special consideration needs to be taken to crossing clock domains since the FPGA system clock is around 6MHz while the sclk signal from the I2S module is 1.411 MHz leading to metastability issues and corruption if transfered without care.\n\n\n\nThis module accepts the mixed packet from the DSP module packet. The tx module while it is a transmitter is configured as a target since it does not generate its own word select (ws). Instead this module uses the ws signal from the controller, the MCU. This ensures that there is no clock drift between the I2S rx and tx module. This module latches a packet one cycle before the tx module finishes sending out the previous packet and then uses a shift register to serialize the captured data out onto an I2S busline along with the forwarded ws and sclk. The output of the I2S tx module is fed into the DAC.\n\n\n\n\n\n\nFigure 1: Top Module Block Diagram"
  },
  {
    "objectID": "FPGA.html#top-internal-modules",
    "href": "FPGA.html#top-internal-modules",
    "title": "FPGA",
    "section": "",
    "text": "This module is responsible for recieving the I2S data from the MCU and converting it into a 16 bit package for the Left and Right channel. This module is mainly a large shifter that shifts the data in and latches the channel values as described by the I2S module, describe in more detail under the documentation tab. This module uses the sclk input as a clock signal to drive the seqquential logic. It wasn’t until later that the team realized this might not have been standard practice and could lead to digital noise.\n\n\n\nThis module accepts the incoming packet from the I2S rx module and syncronizes it to the faster FPGA clock. This module computes the modified packet (wet packet) and mixes it back with the original input (dry packet) to create the mixed packet. Special consideration needs to be taken to crossing clock domains since the FPGA system clock is around 6MHz while the sclk signal from the I2S module is 1.411 MHz leading to metastability issues and corruption if transfered without care.\n\n\n\nThis module accepts the mixed packet from the DSP module packet. The tx module while it is a transmitter is configured as a target since it does not generate its own word select (ws). Instead this module uses the ws signal from the controller, the MCU. This ensures that there is no clock drift between the I2S rx and tx module. This module latches a packet one cycle before the tx module finishes sending out the previous packet and then uses a shift register to serialize the captured data out onto an I2S busline along with the forwarded ws and sclk. The output of the I2S tx module is fed into the DAC.\n\n\n\n\n\n\nFigure 1: Top Module Block Diagram"
  },
  {
    "objectID": "FPGA.html#dsp-internal-modules",
    "href": "FPGA.html#dsp-internal-modules",
    "title": "FPGA",
    "section": "DSP Internal Modules",
    "text": "DSP Internal Modules\n\nCDC FIFO STF and FTS Modules\nThe DSP module needs to handle asyncronous clock domain crossing (CDC). There is a slow to fast (STF) transfer from the I2S rx module to the DSP module shown in Figure 2. There is also a fast to slow (FTS) transfer. These transactions are handled by an the CDC FIFO STF and CDC FIFO FTS which are IP modules provided by Lattice Radiant, our IDE of choice for the FPGA.\n\n\nLFO Gen Module\nThe chorus effect oscilates the amount of delay on a low frequency wave. The LFO gen module generates a low frequency sine wave with a tunable frequency between 0.1-5Hz and a scale between 0-4410. The scale of the sign wave represents the amount of delay ticks to delay the main signal by. Each delay tick is a previous sample (1/(44.1kHs)) seconds ago. The LFO gen is implemented with a look up table (LUT) of sine wave values to expedite processing time and to reduce redundant computations while running.\n\n\nDelay Buffer FSM Module\nA configurable-depth circular delay buffer (FIFO) using an iCE40 SPRAM primitive, operating under a Finite State Machine (FSM) control. It provides a variable delay path for input data packets, designed for audio DSP applications like chorus in our example. The total delay is calculated as the sum of a fixed average delay and a variable offset provided by an external source (e.g., an LFO).The FSM ensures proper read-after-write control and address management to avoid data corruption.\n\n\nMixer Module\nThis module mixes both the wet packet (modified data) and dry packet (unmodified data) by 50%. It accomplishes this by dividing each packet by 2 and then adding the results together. This packet is outputted to the I2S tx module to be sent to the DAC.\n\n\nDSP Module Block Diagram\n\n\n\nFigure 2: DSP Module Block Diagram"
  },
  {
    "objectID": "MCU.html",
    "href": "MCU.html",
    "title": "MCU",
    "section": "",
    "text": "The conditioned guitar signal scaled between 0-3.3V with an offset of 1.65 is passed to channel 8. The ADC is configured in the reset and clock config registers of the MCU to have a speed much faster at sampling than the target audio frequency of 44.1kHz (CD level audio quality). The ADC is triggered by timer 1 to prevent over generation of data that has the chance of overfilling our DMA pipeline or asynch domain crossing FIFO in the FPGA.\n\n\n\nThe DMA is configured in a dual buffer mode and it is circular (when a pointer reaches the end of the buffer it circles back to the start). DMA1 is responsible for collecting the sampled data from the ADC and storing it in an ADC buffer without using CPU time. The data is processed in half cycles. When half of DMA1’s ADC buffer is full it transfers the bottom half of the ADC buffer to the SAI buffer while the top half is collecting data. When DMA1 is full the second half of the ADC buffer is transfered to the SAI buffer while the bottom half fills up. Similarly DMA2 transfers data from the SAI buffer to the SAI module to be sent out as an I2S wave. Both are configured in half-word mode (16 bits).\n\n\n\nThis timer is set up to generate an output event every 44.1kHz. This event is fed to the ADC signaling when the ADC should sample. This is accomplished by clock dividng the system clock down with the Auto relode register.\n\n\n\nThis module outputs the ADC data in I2S format to the FPGA. The SAI module uses the PLLSAI clock generator which has the capability of generating common multiples of clock frequencies in audio processing. Our target was 44.1kHz samples per second, so the PLL was set to generate 25644.1kHz. This is because our SAI module has to output a bit clock 3244.1kHz. We want a new sample every 44.1kHz but since the data is serialized (more info under the documentation tab) it takes 32 sclk cycles to transfer one full left and right sample. Thus our SAI module recieves 256*44.1kHz and divides it by 16 to achieve the desired clock frequency for data transfer."
  },
  {
    "objectID": "MCU.html#summary",
    "href": "MCU.html#summary",
    "title": "MCU",
    "section": "",
    "text": "The conditioned guitar signal scaled between 0-3.3V with an offset of 1.65 is passed to channel 8. The ADC is configured in the reset and clock config registers of the MCU to have a speed much faster at sampling than the target audio frequency of 44.1kHz (CD level audio quality). The ADC is triggered by timer 1 to prevent over generation of data that has the chance of overfilling our DMA pipeline or asynch domain crossing FIFO in the FPGA.\n\n\n\nThe DMA is configured in a dual buffer mode and it is circular (when a pointer reaches the end of the buffer it circles back to the start). DMA1 is responsible for collecting the sampled data from the ADC and storing it in an ADC buffer without using CPU time. The data is processed in half cycles. When half of DMA1’s ADC buffer is full it transfers the bottom half of the ADC buffer to the SAI buffer while the top half is collecting data. When DMA1 is full the second half of the ADC buffer is transfered to the SAI buffer while the bottom half fills up. Similarly DMA2 transfers data from the SAI buffer to the SAI module to be sent out as an I2S wave. Both are configured in half-word mode (16 bits).\n\n\n\nThis timer is set up to generate an output event every 44.1kHz. This event is fed to the ADC signaling when the ADC should sample. This is accomplished by clock dividng the system clock down with the Auto relode register.\n\n\n\nThis module outputs the ADC data in I2S format to the FPGA. The SAI module uses the PLLSAI clock generator which has the capability of generating common multiples of clock frequencies in audio processing. Our target was 44.1kHz samples per second, so the PLL was set to generate 25644.1kHz. This is because our SAI module has to output a bit clock 3244.1kHz. We want a new sample every 44.1kHz but since the data is serialized (more info under the documentation tab) it takes 32 sclk cycles to transfer one full left and right sample. Thus our SAI module recieves 256*44.1kHz and divides it by 16 to achieve the desired clock frequency for data transfer."
  },
  {
    "objectID": "MCU.html#block-diagram-of-mcu",
    "href": "MCU.html#block-diagram-of-mcu",
    "title": "MCU",
    "section": "Block Diagram of MCU",
    "text": "Block Diagram of MCU\n\n\n\nFigure 1: MCU Block Diagram"
  },
  {
    "objectID": "Specifications.html",
    "href": "Specifications.html",
    "title": "Specifications and Results",
    "section": "",
    "text": "For the Micro P’s Project, the specifications are as follows:\n\nAudibly implements the intended effect.\nPhysical switch can toggle the audio effect applied to the input.\nI2S is used to communicate between the MCU and FPGA.\nThe MCU collects samples from the guitar.\nFPGA incorporates the DSP block to implement the intended effect on sampled audio.\nDAC outputs signal compatible with a guitar amplifier.\n\nTechnical Requirements Checklist:\n\nSmooth\nProper amplitude\nAC-coupled\nProper analog input protection and filtering\n3.3V voltage clamping\nBypass capacitance\nUnity gain buffer\nAnti-aliasing filter\nGain"
  },
  {
    "objectID": "Specifications.html#specifications-overview",
    "href": "Specifications.html#specifications-overview",
    "title": "Specifications and Results",
    "section": "",
    "text": "For the Micro P’s Project, the specifications are as follows:\n\nAudibly implements the intended effect.\nPhysical switch can toggle the audio effect applied to the input.\nI2S is used to communicate between the MCU and FPGA.\nThe MCU collects samples from the guitar.\nFPGA incorporates the DSP block to implement the intended effect on sampled audio.\nDAC outputs signal compatible with a guitar amplifier.\n\nTechnical Requirements Checklist:\n\nSmooth\nProper amplitude\nAC-coupled\nProper analog input protection and filtering\n3.3V voltage clamping\nBypass capacitance\nUnity gain buffer\nAnti-aliasing filter\nGain"
  },
  {
    "objectID": "Specifications.html#results",
    "href": "Specifications.html#results",
    "title": "Specifications and Results",
    "section": "Results:",
    "text": "Results:\n\nAudibly Implements the Intended Effect\n\nStatus: The system audibly implements the intended effect.\nEffect details: The project implements a chorus effect. This works by duplicating a sample into a “wet” and “dry” sample and mixing them. The wet sample is stored in memory and delayed by a varying amount determined by a low-frequency oscillator (LFO).\nImplementation: The chorus was implemented on the FPGA using a circular delay buffer module and an LFO module to generate the wet sample, followed by a simple 50% mix of both wet and dry signals.\n\n\n\nPhysical Switch Toggles Audio Effect\n\nGoal: To toggle between the desired effect and a normal output. This allows listeners to audibly distinguish between the implemented effect and the regular guitar output.\nImplementation: A button serves as a system bypass.\nMechanism: Instead of routing the analog guitar wave through the MCU and FPGA, the system bypasses it directly to the amp. This allows for distinguishing between the two signals.\n\n\n\nI2S Communication\n\nUsage: I2S is used for communication between the MCU and FPGA.\nFunction: The MCU sends sampled waves (converted from analog guitar input) to the FPGA to handle the chorus effect.\nProtocol: Communication is established via the SAI module using I2S. This allows for two-channel digital audio transmission as Pulse Code Modulation (PCM), which is essential for high-quality audio.\nSignals: The protocol uses Serial Clock (SCK), Word Select (WS), and Serial Data (SD) to synchronize data transfer.\n\n\n\nMCU Sample Collection\n\nProcess: The MCU collects samples from the guitar using the analog-to-digital converter (ADC) peripheral.\nRequirement: Because the guitar outputs an analog signal, it must be digitally sampled.\nRate: A sample rate of 44.1 kHz was chosen to target CD-quality audio.\n\n\n\nFPGA DSP Block Implementation\n\nImplementation: The FPGA incorporates the DSP block to apply a filter on the sampled audio.\nPurpose: This incorporation is required to achieve the chorus effect.\nLibrary Usage: The DSP library was utilized because the chorus effect requires wave multiplication.\n\n\n\nDAC Output Compatibility\n\nGoal: The DAC must output a signal compatible with a guitar amplifier.\nStatus: This goal is not fully met.\nIssues:\n\nThe signal contains a very audible amount of digital noise and 60 Hz pickup.\nThe I2S introduces infrequent, periodic distortion to the audio.\n\nSuccesses: Aside from the noise, the output is AC-coupled and has the proper amount of gain.\n\n\n\nAnalog Input Protection and Filtering\n\nStatus: This goal was met.\nComponents: The system uses input and output buffers, DC bias, a 4th-order Sallen-Key Butterworth antialiasing filter, and coupling capacitors.\nProtection: Op-amp rails ensure signals greater than 3.3V do not enter the ADC.\nPower: All IC power rails are decoupled with capacitors."
  }
]